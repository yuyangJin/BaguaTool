from __future__ import division

import tempfile
import os
import textwrap
import subprocess as sub
import math

from exceptions import PyCallGraphException
from color import Color
from output import Output

class GraphvizOutput(Output):
    def __init__(self, file_name, **kwargs):
        self.tool = 'dot'
        #self.tool = 'circo'
        #self.tool = 'neato'
        if output_file == "":
            #self.output_files = [file_name + '.png', file_name + '.pdf']
            #self.output_types = ['png', 'pdf']
            self.output_files = [file_name + '.pdf']
            self.output_types = ['pdf']
        else:
            #self.output_files = [output_file + '.png', output_file + '.pdf']
            #self.output_types = ['png', 'pdf']
            self.output_files = [output_file + '.pdf']
            self.output_types = ['pdf']
        self.font_name = 'Verdana'
        self.font_size = 7
        self.group_font_size = 10
        self.group_border_color = Color(0, 0, 0, 0.8)
        self.input_edges = edges
        self.file_name = file_name

        Output.__init__(self, total_sample_count, total_comm_time, **kwargs)

        self.prepare_graph_attributes()

    @classmethod
    def add_arguments(cls, subparsers, parent_parser, usage):
        defaults = cls()

        subparser = subparsers.add_parser(
            'graphviz', help='Graphviz generation',
            parents=[parent_parser], usage=usage,
        )

        subparser.add_argument(
            '-l', '--tool', dest='tool', default=defaults.tool,
            help='The tool from Graphviz to use, e.g. dot, neato, etc.',
        )

        cls.add_output_file(
            subparser, defaults, 'The generated Graphviz file'
        )

        subparser.add_argument(
            '-f', '--output-format', type=str, default=defaults.output_types[0],
            dest='output_type',
            help='Image format to produce, e.g. png, ps, dot, etc. '
            'See http://www.graphviz.org/doc/info/output.html for more.',
        )

        subparser.add_argument(
            '--font-name', type=str, default=defaults.font_name,
            help='Name of the font to be used',
        )

        subparser.add_argument(
            '--font-size', type=int, default=defaults.font_size,
            help='Size of the font to be used',
        )
    
    def prepare_graph_attributes(self):
        generated_message = '\\n'.join([
            r'Generated by BaguaTool from PACMAN',
        ])

        self.graph_attributes = {
            'graph': {
                'overlap': 'scalexy',
                'fontname': self.font_name,
                'fontsize': self.font_size,
                'fontcolor': Color(0, 0, 0, 0.5).rgba_web(),
                'label': generated_message,
            },
            'node': {
                'fontname': self.font_name,
                'fontsize': self.font_size,
                'fontcolor': Color(0, 0, 0).rgba_web(),
                'style': 'filled',
                'shape': 'rect',
            },
            'edge': {
                'fontname': self.font_name,
                'fontsize': self.font_size,
                'fontcolor': Color(0, 0, 0).rgba_web(),
            }
        }

    def done(self):
        # source = self.generate()

        # fd, temp_name = tempfile.mkstemp()
        # with os.fdopen(fd, 'w') as f:
        #     f.write(source)

        for i in range(len(self.output_types)):
            output_type = self.output_types[i]
            output_file = self.output_files[i]
            cmd = '"{0}" -v -T {1} -o {2} {3}'.format(
                self.tool, output_type, output_file, self.file_name
            )

            self.verbose('Executing: {0}'.format(cmd))
            proc = sub.Popen(cmd, stdout=sub.PIPE, stderr=sub.PIPE, shell=True)
            stdout, stderr = proc.communicate()
            exit_code = proc.wait()
            #print(stdout, output, exit_code)
            if exit_code:
                os.unlink(temp_name)
                raise PyCallGraphException(
                    'The command "%(cmd)s" failed with error '
                    'stdout: %(stdout)s stderr: %(stderr)s code %(ret)i.' % locals())
        #    finally:
        os.unlink(temp_name)

        #self.verbose('Generated {0} with {1} nodes.'.format(
        #    self.output_file, len(self.processor.func_count),
        #))
    
    # def generate(self):
    #     '''Returns a string with the contents of a DOT file for Graphviz to
    #     parse.
    #     '''
    #     indent_join = '\n' + ' ' * 12

    #     if self.root_node != None:
    #         self.generateNodesEdgesGroups(self.root_node)
    #     else:
    #         self.generateNodesEdgesGroupsByNodeEdges(self.input_nodes, self.input_edges)
        
    #     self.generateEdgeFromEdgeList()
    #     self.generateRedEdgeFromRedEdgeList()
    #     return textwrap.dedent('''\
    #     digraph G {{
    #         // Attributes
    #         {0}
    #         // Groups
    #         {1}
    #         // Nodes
    #         {2}
    #         // Edges
    #         {3}
    #     }}
    #     '''.format(
    #         indent_join.join(self.generate_attributes()),
    #         # indent_join.join(self.generate_groups()),
    #         # indent_join.join(self.generate_nodes()),
    #         # indent_join.join(self.generate_edges()),
    #         indent_join.join(self.groups),
    #         indent_join.join(self.nodes),
    #         indent_join.join(self.edges),
    #     ))

    # def attrs_from_dict(self, d):
    #     output = []
    #     for attr, val in d.items():
    #         output.append('%s = "%s"' % (attr, val))
    #     return ', '.join(output)


    # def node(self, key, attr):
    #     return '"{0}" [{1}];'.format(
    #         key, self.attrs_from_dict(attr),
    #     )

    # # def edge(self, edge, attr):
    # #     return '"{0.src_func}" -> "{0.dst_func}" [{1}];'.format(
    # #         edge, self.attrs_from_dict(attr),
    # #     )
    # def edge(self, edge_src, edge_dest, attr):
    #     return '"{0}" -> "{1}" [{2}];'.format(
    #         edge_src, edge_dest, self.attrs_from_dict(attr),
    # )

    # def generate_attributes(self):
    #     output = []
    #     for section, attrs in self.graph_attributes.items():
    #         output.append('{0} [ {1} ];'.format(
    #             section, self.attrs_from_dict(attrs),
    #         ))
    #     return output
    
    # # def generate_groups(self):
    # #     if not self.processor.config.groups:
    # #         return ''

    # #     output = []
    # #     for group, nodes in self.processor.groups():
    # #         funcs = [node.name for node in nodes]
    # #         funcs = '" "'.join(funcs)
    # #         group_color = self.group_border_color.rgba_web()
    # #         group_font_size = self.group_font_size
    # #         output.append(
    # #             'subgraph "cluster_{group}" {{ '
    # #             '"{funcs}"; '
    # #             'label = "{group}"; '
    # #             'fontsize = "{group_font_size}"; '
    # #             'fontcolor = "black"; '
    # #             'style = "bold"; '
    # #             'color="{group_color}"; }}'.format(**locals()))
    # #     return output

    # # def generate_nodes(self):
    # #     output = []
    # #     for node in self.processor.nodes():
    # #         attr = {
    # #             'color': self.node_color_func(node).rgba_web(),
    # #             'label': self.node_label_func(node),
    # #         }
    # #         output.append(self.node(node.name, attr))

    # #     return output

    # # def generate_edges(self):
    # #     output = []

    # #     for edge in self.processor.edges():
    # #         attr = {
    # #             'color': self.edge_color_func(edge).rgba_web(),
    # #             'label': self.edge_label_func(edge),
    # #         }
    # #         output.append(self.edge(edge, attr))

    # #     return output 



    # def generateNodesEdgesGroups(self, node):
    #     global group_id

    #     if node.generated_nodes_edges_groups:
    #         return
    #     node.generated_nodes_edges_groups = True
    #     # Add nodes
    #     #print(node.unique_id, node.type_name, node.performance_percentage)
    #     attr = {
    #         'color': self.node_color_func(node).rgba_web(),
    #         'label': self.node_label_func(node),
    #     }
    #     #if node.removed == False:
    #     #    self.nodes.append(self.node(node.unique_id, attr))
    #     self.nodes.append(self.node(node.unique_id, attr))
    #     #self.percentage_sum += node.performance_percentage

    #     #Add group 
    #     #if node.group_flag == True:
    #     if node.unique_id in self.group_list:
    #         funcs = []
    #         #for child in node.children:
    #         #    if child.removed == False:
    #         #        funcs.append(str(child.unique_id))
    #         funcs = [str(node.unique_id)] # for child in node.children]
    #         funcs = '" "'.join(funcs)
    #         group_color = self.group_border_color.rgba_web()
    #         group_font_size = self.group_font_size
    #         group = self.group_id
    #         self.groups.append(
    #             'subgraph "cluster_{group}" {{ '
    #             '"{funcs}"; '
    #             'label = "{group}"; '
    #             'fontsize = "{group_font_size}"; '
    #             'fontcolor = "black"; '
    #             'style = "bold"; '
    #             'color="{group_color}"; }}'.format(**locals()))
    #         self.group_id += 1
    #     # if node.type == "CALL_IND":
    #     #     funcs = []
    #     #     funcs = [str(child.unique_id) for child in node.children]
    #     #     funcs = '" "'.join(funcs)
    #     #     group_color = self.group_border_color.rgba_web()
    #     #     group_font_size = self.group_font_size
    #     #     #group = self.group_id
    #     #     group = node.unique_id
    #     #     self.groups.append(
    #     #         'subgraph "cluster_{group}" {{ '
    #     #         '"{funcs}"; '
    #     #         'label = "{group}"; '
    #     #         'fontsize = "{group_font_size}"; '
    #     #         'fontcolor = "black"; '
    #     #         'style = "bold"; '
    #     #         'color="{group_color}"; }}'.format(**locals()))
    #     #     self.group_id += 1

    #     #Add edges
    #     if len(node.children) > 0:
    #         for child in node.children:
    #             attr = {
    #                 'color': self.edge_color_func(node.unique_id).rgba_web(),
    #                 'label': self.edge_label_func(""),
    #             }
    #             # if child.removed == False:
    #             #     self.edges.append(self.edge(node.unique_id, child.unique_id, attr))
    #             #     self.generateNodesEdgesGroups(child)
    #             self.edges.append(self.edge(node.unique_id, child.unique_id, attr))
    #             self.generateNodesEdgesGroups(child)

    # def generateNodesEdgesGroupsByNodeEdges(self, input_nodes, input_edges):
    #     global group_id

    #     # Add nodes

    #     for k, v in input_nodes.items():
    #         attr = {
    #             'color': Color.hsv(0,0.02,0.9).rgba_web(),
    #             'label': str(k),
    #         }
    #         self.nodes.append(self.node(k, attr))

    #     #Add group 
    #     # if node.group_flag == True:
    #     #     funcs = []
    #     #     #for child in node.children:
    #     #     #    if child.removed == False:
    #     #     #        funcs.append(str(child.unique_id))
    #     #     funcs = [str(node.unique_id)] # for child in node.children]
    #     #     funcs = '" "'.join(funcs)
    #     #     group_color = self.group_border_color.rgba_web()
    #     #     group_font_size = self.group_font_size
    #     #     group = self.group_id
    #     #     self.groups.append(
    #     #         'subgraph "cluster_{group}" {{ '
    #     #         '"{funcs}"; '
    #     #         'label = "{group}"; '
    #     #         'fontsize = "{group_font_size}"; '
    #     #         'fontcolor = "black"; '
    #     #         'style = "bold"; '
    #     #         'color="{group_color}"; }}'.format(**locals()))
    #     #     self.group_id += 1
    #     # if node.type == "CALL_IND":
    #     #     funcs = []
    #     #     funcs = [str(child.unique_id) for child in node.children]
    #     #     funcs = '" "'.join(funcs)
    #     #     group_color = self.group_border_color.rgba_web()
    #     #     group_font_size = self.group_font_size
    #     #     #group = self.group_id
    #     #     group = node.unique_id
    #     #     self.groups.append(
    #     #         'subgraph "cluster_{group}" {{ '
    #     #         '"{funcs}"; '
    #     #         'label = "{group}"; '
    #     #         'fontsize = "{group_font_size}"; '
    #     #         'fontcolor = "black"; '
    #     #         'style = "bold"; '
    #     #         'color="{group_color}"; }}'.format(**locals()))
    #     #     self.group_id += 1

    #     #Add edges
    #     for k,v in input_edges.items():
    #         for child in v:
    #             attr = {
    #                 'color': self.edge_color_func(k).rgba_web(),
    #                 'label': self.edge_label_func(""),
    #             }
    #             self.edges.append(self.edge(k, child, attr))
        
    # def generateEdgeFromEdgeList(self):
    #     #print(self.edge_list)
    #     for edge_ in self.edge_list:
    #         #if edge_[0] in self.group_list or edge_[1] in self.group_list:
    #         if edge_[2] > 1e4 :
    #             attr = {
    #                 'color': self.edge_color_func(edge_[2]).rgba_web(),
    #                 'label': self.edge_label_func(str(edge_[2])),
    #                 'penwidth':self.edge_penwidth_func((math.log(edge_[2], 10)) * 2 - 7 ),
    #             }
    #         else:
    #             attr = {
    #                 'color': self.edge_color_func(edge_[2]).rgba_web(),
    #                 'label': self.edge_label_func(str(edge_[2])),
    #                 'penwidth':self.edge_penwidth_func(1),
    #             }
    #         # if child.removed == False:
    #         #     self.edges.append(self.edge(node.unique_id, child.unique_id, attr))
    #         #     self.generateNodesEdgesGroups(child)
    #         self.edges.append(self.edge(edge_[0], edge_[1], attr))

    # def generateRedEdgeFromRedEdgeList(self):
    #     for edge_ in self.red_edge_list:
    #         attr = {
    #             'color': '#FF0000',
    #             #'label': self.edge_label_func(''),
    #             'penwidth':self.edge_penwidth_func(10),
    #         }
    #         # if child.removed == False:
    #         #     self.edges.append(self.edge(node.unique_id, child.unique_id, attr))
    #         #     self.generateNodesEdgesGroups(child)
    #         self.edges.append(self.edge(edge_[0], edge_[1], attr))